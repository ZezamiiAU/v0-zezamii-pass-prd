# PIN Code Security Design

## Overview

This document explains the security model for PIN codes in the Zezamii Pass system.

## Storage Decision: Plaintext

**PIN codes are stored in plaintext (not hashed) for the following reasons:**

### Why NOT Hash?

1. **PINs Are Not Passwords**
   - Passwords = long-term authentication credentials (must be hashed)
   - PINs = temporary access codes with different security model

2. **Must Be Retrievable**
   - Display to users after purchase
   - Send via SMS/email for recovery
   - Support staff lookup for customer service
   - Printed on receipts/tickets

3. **Time-Limited Security**
   - Expires automatically with pass validity (24h, 7d, etc.)
   - Not a persistent authentication credential
   - Limited attack window

4. **Physical Access Control**
   - Used at keypads, not for system authentication
   - Protected by physical security measures
   - Rate limiting at lock hardware level

5. **Customer Support**
   - Staff must help users who forgot/lost PIN
   - Cannot retrieve hashed values
   - Business requirement

## Security Measures

Instead of hashing, we use multiple defense layers:

### 1. Time-Limited Expiration
- PIN expires with pass validity
- Automatic revocation after pass end date
- No long-term exposure risk

### 2. Database Security
- Supabase Row Level Security (RLS) policies
- Service role access only for PIN reads
- Encrypted database connections (TLS)
- Regular database backups with encryption

### 3. Transmission Security
- HTTPS/TLS for all API communication
- No PIN codes in URLs (POST body only)
- Secure webhook endpoints with auth

### 4. Access Control
- API authentication required for lookups
- Rate limiting on pass lookup endpoints
- Audit logging of PIN access
- IP-based access restrictions

### 5. Application Security
- Never log PIN codes in application logs
- Sanitize error messages (no PIN leakage)
- Memory cleared after use
- No client-side caching of PINs

### 6. Physical Security
- Lock hardware rate limiting (3-5 attempts)
- Lockout after failed attempts
- Physical access to keypads required
- Security cameras at access points

## PIN Code Format

### Configurable Length
- Stored per-site in `core.lock_system_config`
- Default: 6 digits
- Range: 4-8 digits
- Numeric only (0-9)

### Generation
- Generated by Duvan's lock system
- Cryptographically random (assumed)
- Unique per pass
- No predictable patterns

### Validation
\`\`\`typescript
// Numeric only
/^\d+$/.test(pinCode)

// Correct length for site
pinCode.length === expectedLength

// Not expired
pass.valid_to > now()
\`\`\`

## Threat Model

### Threats We Mitigate:
- ✅ Database breach (RLS + encryption at rest)
- ✅ Man-in-the-middle (TLS)
- ✅ Brute force at keypad (hardware rate limiting)
- ✅ Unauthorized API access (authentication + RLS)
- ✅ Log file exposure (PINs never logged)

### Acceptable Risks:
- ⚠️ Compromised service role credentials → Full database access
  - Mitigation: Rotate credentials regularly, monitor access patterns
- ⚠️ Physical observation at keypad → PIN stolen
  - Mitigation: Security cameras, shield at keypad, time limits
- ⚠️ Short PIN length (4 digits) → 10,000 combinations
  - Mitigation: Hardware lockout after failures, time limits

## Comparison: PIN vs Password

| Aspect | Password (Hash) | PIN (Plaintext) |
|--------|----------------|-----------------|
| **Purpose** | Authentication | Physical access |
| **Lifetime** | Permanent | Hours/days |
| **Length** | 8-20+ chars | 4-8 digits |
| **Retrieval** | Never | Required |
| **Support** | Reset only | Lookup/resend |
| **Attacks** | Online brute force | Physical keypad |
| **Defense** | Hashing + salt | Time limits + hardware |

## Regulatory Compliance

### PCI DSS
- Not applicable (PINs are not payment card PINs)
- Payment data handled by Stripe (PCI compliant)

### GDPR
- PIN linked to pass, not user account
- Anonymous purchases possible
- Data retention tied to pass expiration
- Right to deletion supported

### Data Retention
- PIN retained while pass is valid
- Deleted after pass expires + grace period (30d)
- Audit logs retained separately (compliance)

## Monitoring & Audit

### Logged Events:
- PIN generation (passId, timestamp)
- PIN lookup (who, when, passId)
- Failed access attempts (keypad logs)
- Pass expiration (PIN invalidated)

### Never Logged:
- Actual PIN code value
- Failed PIN attempts (privacy)
- User PII alongside PIN

## Best Practices

### For Developers:
\`\`\`typescript
// ✅ Good: Secure PIN handling
const pass = await getPassById(passId)
sendEmailWithPin(pass.purchaser_email, pass.pin_code)

// ❌ Bad: Logging PIN
logger.info({ pin: pass.pin_code }) // NEVER DO THIS

// ✅ Good: Masked logging
logger.info({ passId, pinStatus: pass.pin_status })
\`\`\`

### For Operations:
- Rotate database credentials quarterly
- Monitor unusual access patterns
- Audit PIN lookups monthly
- Review security logs weekly

## Alternative Approaches Considered

### 1. Encrypt PINs (AES-256)
**Why not:** 
- Key management complexity
- Must decrypt for every display
- Service must hold decryption key (same risk)
- Time-limited PINs don't warrant complexity

### 2. One-Time Use Tokens
**Why not:**
- Keypad hardware expects numeric PIN
- Cannot change lock system requirements
- User experience worse (QR codes, etc.)

### 3. Per-Entry PIN Rotation
**Why not:**
- Lock system generates PIN once
- Cannot regenerate per access
- Hardware limitation

## Conclusion

Storing PINs in plaintext is a **deliberate security decision** based on:
- Business requirements (retrieval, support)
- Threat model (time-limited physical access)
- Hardware constraints (numeric keypad)
- Defense-in-depth strategy (multiple security layers)

This approach is **appropriate and secure** for temporary physical access codes, distinct from authentication passwords.
